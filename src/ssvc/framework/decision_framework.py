#!/usr/bin/env python

#  Copyright (c) 2025 Carnegie Mellon University and Contributors.
#  - see Contributors.md for a full list of Contributors
#  - see ContributionInstructions.md for information on how you can Contribute to this project
#  Stakeholder Specific Vulnerability Categorization (SSVC) is
#  licensed under a MIT (SEI)-style license, please see LICENSE.md distributed
#  with this Software or contact permission@sei.cmu.edu for full terms.
#  Created, in part, with funding and support from the United States Government
#  (see Acknowledgments file). This program may include and/or can make use of
#  certain third party source code, object code, documentation and other files
#  (“Third Party Software”). See LICENSE.md for more details.
#  Carnegie Mellon®, CERT® and CERT Coordination Center® are registered in the
#  U.S. Patent and Trademark Office by Carnegie Mellon University
"""
Provides a Decision Framework class that can be used to model decisions in SSVC
"""
import pandas as pd
from pydantic import BaseModel

from ssvc._mixins import _Base, _Namespaced, _Versioned
from ssvc.dp_groups.base import SsvcDecisionPointGroup
from ssvc.outcomes.base import OutcomeGroup
from ssvc.policy_generator import PolicyGenerator


class DecisionFramework(_Versioned, _Namespaced, _Base, BaseModel):
    """
    The DecisionFramework class is a model for decisions in SSVC.

    It is a collection of decision points and outcomes, and a mapping of decision points to outcomes.

    The mapping is generated by the PolicyGenerator class, and stored as a dictionary.
    The mapping dict keys are tuples of decision points and decision point values.
    The mapping dict values are outcomes.
    """

    decision_point_group: SsvcDecisionPointGroup
    outcome_group: OutcomeGroup
    mapping: dict[str, str]

    def __init__(self, **data):
        super().__init__(**data)

        if not self.mapping:
            self.mapping = self.generate_mapping()

    def generate_mapping(self) -> dict[str, str]:
        """
        Populate the mapping with all possible combinations of decision points.
        """
        mapping = {}
        dp_lookup = {
            dp.name.lower(): dp for dp in self.decision_point_group.decision_points
        }
        outcome_lookup = {
            outcome.name.lower(): outcome for outcome in self.outcome_group.outcomes
        }

        dp_value_lookup = {}
        for dp in self.decision_point_group.decision_points:
            key1 = dp.name.lower()
            dp_value_lookup[key1] = {}
            for dp_value in dp.values:
                key2 = dp_value.name.lower()
                dp_value_lookup[key1][key2] = dp_value

        with PolicyGenerator(
            dp_group=self.decision_point_group,
            outcomes=self.outcome_group,
        ) as policy:
            table: pd.DataFrame = policy.clean_policy()

        # the table is a pandas DataFrame
        # the columns are the decision points, with the last column being the outcome
        # the rows are the possible combinations of decision points
        # we need to convert this back to specific decision points and outcomes
        for row in table.itertuples():
            outcome_name = row[-1].lower()
            outcome = outcome_lookup[outcome_name]

            dp_value_names = row[1:-1]
            dp_value_names = [dp_name.lower() for dp_name in dp_value_names]

            columns = [col.lower() for col in table.columns]

            # construct the key for the mapping
            dp_values = []
            for col, val in zip(columns, dp_value_names):
                value_lookup = dp_value_lookup[col]
                dp = dp_lookup[col]
                val = value_lookup[val]

                key_delim = ":"
                k = key_delim.join([dp.namespace, dp.key, val.key])
                dp_values.append(k)

            key = ",".join([str(k) for k in dp_values])

            outcome_group = self.outcome_group
            outcome_str = ":".join([outcome_group.key, outcome.key])

            mapping[key] = outcome_str

        return mapping


# convenience alias
Policy = DecisionFramework


def main():
    from ssvc.dp_groups.ssvc.supplier import LATEST as dpg
    from ssvc.outcomes.groups import MOSCOW as og

    dfw = DecisionFramework(
        name="Example Decision Framework",
        description="The description for an Example Decision Framework",
        version="1.0.0",
        decision_point_group=dpg,
        outcome_group=og,
        mapping={},
    )
    print(dfw.model_dump_json(indent=2))


if __name__ == "__main__":
    main()
