#!/usr/bin/env python

#  Copyright (c) 2025 Carnegie Mellon University.
#  NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE
#  ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS.
#  CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND,
#  EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT
#  NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR
#  MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE
#  OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE
#  ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM
#  PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
#  Licensed under a MIT (SEI)-style license, please see LICENSE or contact
#  permission@sei.cmu.edu for full terms.
#  [DISTRIBUTION STATEMENT A] This material has been approved for
#  public release and unlimited distribution. Please see Copyright notice
#  for non-US Government use and distribution.
#  This Software includes and/or makes use of Third-Party Software each
#  subject to its own license.
#  DM24-0278
"""
Provides a DecisionTable class that can be used to model decisions in SSVC
"""
import itertools
import logging
from typing import Optional

import networkx as nx
import pandas as pd
from pydantic import BaseModel, Field

from ssvc._mixins import _Base, _Commented, _Namespaced, _SchemaVersioned
from ssvc.dp_groups.base import DecisionPointGroup
from ssvc.outcomes.base import OutcomeGroup
from ssvc.policy_generator import PolicyGenerator

logger = logging.getLogger(__name__)


class DecisionTable(_SchemaVersioned, _Namespaced, _Base, _Commented, BaseModel):
    """
    The DecisionTable class is a model for decisions in SSVC.

    It is a collection of decision points and outcomes, and a mapping of decision points to outcomes.

    The mapping is generated by the PolicyGenerator class, and stored as a dictionary.
    The mapping dict keys are tuples of decision points and decision point values.
    The mapping dict values are outcomes.
    """

    decision_point_group: DecisionPointGroup
    outcome_group: OutcomeGroup
    mapping: list[tuple[tuple[str, ...], tuple[str, ...]]] = Field(default_factory=list)

    def get_mapping_df(self, weights: Optional[list[float]] = None) -> pd.DataFrame:
        # create a policy generator object and extract a mapping from it
        with PolicyGenerator(
            dp_group=self.decision_point_group,
            outcomes=self.outcome_group,
            outcome_weights=weights,
        ) as pg:
            df = pg.clean_policy()

        return df

    def dataframe_to_tuple_list(
        self, df: pd.DataFrame, n_outcols: int = 1
    ) -> list[tuple[tuple[str, ...], tuple[str, ...]]]:
        """
        Converts a DataFrame into a list of tuples where each tuple contains:
        - A tuple of input values (all columns except the last n_outcols)
        - A tuple containing the outcome value (last n_outcols columns)

        Note:
            In every decision we've modeled to date, there is only one outcome column.
            We have not yet encountered a decision with multiple outcome columns,
            however, it has come up in some discussions, so we're allowing for it here as
            a future-proofing measure.

        Attributes:
            df: pandas DataFrame
            n_outcols: int, default=1

        Returns:
            list[tuple[tuple[str,...],tuple[str,...]]]: A list of tuples

        """
        input_columns = df.columns[:-n_outcols]  # All columns except the last one
        output_column = df.columns[-n_outcols]  # The last column

        return [
            (tuple(row[input_columns]), (row[output_column],))
            for _, row in df.iterrows()
        ]

    def set_mapping(
        self, df: pd.DataFrame
    ) -> list[tuple[tuple[str, ...], tuple[str, ...]]]:
        """
        Sets the mapping attribute to the output of dataframe_to_tuple_list

        :param df: pandas DataFrame
        """
        self.mapping = self.dataframe_to_tuple_list(df)
        return self.mapping

    def generate_mapping(self) -> list[tuple[tuple[str, ...], tuple[str, ...]]]:
        """
        Generates a mapping from the decision point group to the outcome group using the PolicyGenerator class
        and sets the mapping attribute to the output of dataframe_to_tuple_list

        Returns:
            list[tuple[tuple[str,...],tuple[str,...]]]: The generated mapping
        """
        df = self.get_mapping_df()
        return self.set_mapping(df)

    def consistency_check_mapping(self) -> bool:
        """Checks the mapping attribute by ensuring that the contents are consistent with the partial order over the decision points and outcomes"""

        # convert the decision point values to a list of numerical tuples
        # and create a lookup table for the values
        # The end result will be that vector contains a list of tuples
        # where each tuple is a list of integers that represent the values
        # in a decision point. The dp_lookup list will contain a dictionary
        # for each decision point that maps the integer values to the string values
        vector = []
        dp_lookup = []

        # create an inverted index for the outcomes
        outcome_lookup = {v: k for k, v in self.outcome_group.enumerated_values.items()}
        logger.debug(f"Outcome lookup: {outcome_lookup}")

        for dp in self.decision_point_group:
            valuesdict = dp.enumerated_values
            dp_lookup.append(valuesdict)

            _vlist = tuple(valuesdict.keys())
            vector.append(_vlist)

        # vector now looks like
        # [(0, 1, 2), (0, 1), (0, 1, 2, 3)]
        logger.debug(f"Vector: {vector}")
        # dp_lookup looks like
        # [{0: 'a', 1: 'b', 2: 'c'}, {0: 'x', 1: 'y'}, {0: 'i', 1: 'j', 2: 'k', 3: 'l'}]
        logger.debug(f"DP lookup: {dp_lookup}")

        bottom = tuple([min(t) for t in vector])
        top = tuple([max(t) for t in vector])

        logger.debug(f"Bottom node: {bottom}")
        logger.debug(f"Top node: {top}")

        # construct a directed graph
        G = nx.DiGraph()
        G = self._add_nodes(G, vector)
        G = self._add_edges(G)

        problems = self._check_graph(G, bottom, top)

        # if we already have problems, we should stop here
        # because the graph is not valid
        if problems:
            for problem in problems:
                logger.error(f"Problem detected: {problem}")
            return False

        # the graph has a lot of edges where the outcome does not change between the nodes
        # we need to find the decision boundaries where the outcome does change
        decision_boundaries = self._find_decision_boundaries(G, dp_lookup)

        problems = self._check_decision_boundaries(decision_boundaries, outcome_lookup)
        for problem in problems:
            logger.error(f"Problem detected: {problem}")

        # return True if there are no problems
        return len(problems) == 0

    def _check_decision_boundaries(
        self, decision_boundaries: list[dict[str, str]], outcome_lookup: dict[str, int]
    ) -> list[str]:

        problems = []
        for db in decision_boundaries:
            from_outcome = outcome_lookup[db["from_outcome"]]
            to_outcome = outcome_lookup[db["to_outcome"]]

            if from_outcome < to_outcome:
                # this is what we wanted, no problem found
                continue

            problem = (
                f"{db['from']} < {db['to']} but {from_outcome} is not < {to_outcome}"
            )
            problems.append(problem)
        return problems

    def _find_decision_boundaries(
        self, G: nx.DiGraph, dp_lookup: list[dict[int, str]]
    ) -> list[dict[str, str]]:
        decision_boundaries = []
        for edge in G.edges:
            u, v = edge

            # we need to translate from a node int tuple to the strings so we can look it up in the mapping
            u_str = self.int_node_to_str(u, dp_lookup)
            v_str = self.int_node_to_str(v, dp_lookup)

            mapping_dict = dict(self.mapping)
            try:
                u_outcome_str = mapping_dict[u_str][0]
            except KeyError:
                print(f"Node {u_str} has no mapping")

            try:
                v_outcome_str = mapping_dict[v_str][0]
            except KeyError:
                logger.error(f"Node {v_str} has no mapping")
                raise ValueError

            if u_outcome_str == v_outcome_str:
                # no decision boundary here
                continue

            # if we got here, there is a decision boundary
            # so we need to record it
            row = {
                "from": u_str,
                "to": v_str,
                "from_outcome": u_outcome_str,
                "to_outcome": v_outcome_str,
            }
            decision_boundaries.append(row)

        return decision_boundaries

    def int_node_to_str(
        self, node: tuple[int, ...], dp_lookup: list[dict[int, str]]
    ) -> tuple[str, ...]:
        return tuple([dp_lookup[i][node[i]] for i in range(len(node))])

    def _check_graph(
        self, G: nx.DiGraph, bottom: tuple[int, ...], top: tuple[int, ...]
    ) -> list[str]:
        problems = []
        # check nodes for edges
        for node in G.nodes:
            if node != bottom and not G.in_degree(node):
                # all nodes except bottom should have at least one incoming edge
                problems.append(f"Node {node} has no incoming edges")
            if node != top and not G.out_degree(node):
                # all nodes except top should have at least one outgoing edge
                problems.append(f"Node {node} has no outgoing edges")
        return problems

    def _add_nodes(self, G: nx.DiGraph, vector: list[tuple[int, ...]]) -> nx.DiGraph:

        for node in itertools.product(*vector):
            node = tuple(node)
            # node is a tuple of integers
            G.add_node(node)

        return G

    def _add_edges(self, G: nx.DiGraph) -> nx.DiGraph:
        """
        Add edges to the graph G based on the nodes in G.
        Node identities are tuples of integers.
        Edges are added between nodes where one and only one element of the tuples differ by 1.

        Examples:

            | Node 1 | Node 2 | Edge? |
            |--------|--------|-------|
            | (0,0)  | (0,1)  | Yes   |
            | (0,0)  | (1,0)  | Yes   |
            | (0,0)  | (1,1)  | No    |
            | (0,0)  | (0,0)  | No    |
            | (0,0)  | (0,2)  | No    |
            | (0,1)  | (0,2)  | Yes   |

        Args:
            G: a networkx DiGraph object

        Returns:
            a networkx DiGraph object with edges added

        """
        # add edges
        for u, v in itertools.product(G.nodes, G.nodes):
            # enforce that u and v are tuples of integers
            if not isinstance(u, tuple) or any([not isinstance(i, int) for i in u]):
                raise ValueError(f"Node {u} is not an integer tuple")
            if not isinstance(v, tuple) or any([not isinstance(i, int) for i in v]):
                raise ValueError(f"Node {v} is not an integer tuple")

            # add an edge if the difference between u and v is 1
            if u == v:
                # do not create self-reflexive edges
                continue

            if any(u[i] > v[i] for i in range(len(u))):
                # skip the upper triangle of the connectivity matrix
                continue

            # if you get here, we know that u < v, but it could be
            # a gap larger than 1 from u to v.
            # We only want to add edges where the gap is exactly 1.

            # compute the individual differences for each vector element
            delta = [v[i] - u[i] for i in range(len(u))]

            if sum(delta) != 1:
                # gap is too large
                continue

            if not all([d in [0, 1] for d in delta]):
                # more than one element is different
                # this would be odd if it happened, but check for it anyway
                continue

            # if you get here, then there is exactly one element that is different
            # by 1, and the rest are the same
            # add the edge
            G.add_edge(u, v)

        # clean up the graph before we return it
        # the transitive reduction of a graph is a graph with the same
        # reachability properties, but with as few edges as possible
        # https://en.wikipedia.org/wiki/Transitive_reduction
        # in principle, our algorithm above shouldn't create any redundant edges
        # so this is more of a belt-and-suspenders approach
        before = len(G.edges)
        G = nx.transitive_reduction(G)
        after = len(G.edges)
        if before != after:
            logger.warning(f"Transitive reduction removed {before - after} edges")
        logger.debug(f"Edge count: {after}")
        return G

    def mapping_to_csv_str(self):
        """
        Returns the mapping as a CSV string
        """
        columns = [dp.str for dp in self.decision_point_group]
        columns.append(self.outcome_group.str)

        rows = []
        for dpstrs, ostrs in self.mapping:
            row = list(dpstrs)
            row.append(ostrs[0])
            rows.append(row)

        return pd.DataFrame(rows, columns=columns).to_csv(index=False)

    def load_from_csv_str(self, csv_str: str):
        """
        Loads the mapping from a CSV string
        """
        # TODO add a mechanism to read a mapping from a CSV file and create a DecisionTable object from it
        raise NotImplementedError


# convenience alias
Policy = DecisionTable


def main():
    from ssvc.dp_groups.ssvc.coordinator_publication import LATEST as dpg
    from ssvc.outcomes.ssvc_.publish import PUBLISH as og

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    logger.addHandler(logging.StreamHandler())

    dt = DecisionTable(
        name="Example Decision Table",
        description="The description for an Example Decision Table",
        namespace="x_test",
        version="1.0.0",
        decision_point_group=dpg,
        outcome_group=og,
    )

    df = dt.get_mapping_df()
    dt.set_mapping(df)

    print(dt.model_dump_json(indent=2))

    with open("foo.json", "w") as f:
        f.write(dt.model_dump_json())

    dt.consistency_check_mapping()

    print(dt.mapping_to_csv_str())


if __name__ == "__main__":
    main()
